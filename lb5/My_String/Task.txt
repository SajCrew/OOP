Задание 2 – До 300 баллов
Реализовать и протестировать класс CMyString, моделирующий строку произвольной длины.

Внимание, строка должна позволять хранить в середине символы с нулевым кодом (подсказка: реализация класса строк должна помимо адреса первого элемента массива символов в динамической памяти хранить еще и длину строки, т.к. использование функций вроде strlen, strcpy и им подобных, воспринимающих символ с нулевым кодом как символ конца строки, не решает данную проблему. Кроме того в массиве потребуется зарезервировать место под символ с нулевым кодом в конце строки, т.к. метод GetStringData(), объявленный в классе CMyString, согласно условиям задачи возвращает указатель на строку с завершающим нулевым символом.). Проинициализировать такую строку можно при помощи конструктора, принимающего кроме адреса первого символа длину строки.

Строка должна иметь кроме размера вместимость — количество символов, которое может поместиться в строке без перевыделения памяти. При увеличении размера строки (например, в результате операции +=), вместимость должна удваиваться. Например, строка вместимостью 10 символов и длиной 10 символов при добавлении в неё одного символа должна увеличить вместимость до 20 символов.

Каркас класса:

class CMyString
{
public:
    // конструктор по умолчанию
    CMyString();

    // конструктор, инициализирующий строку данными строки
    // с завершающим нулевым символом
    CMyString(const char * pString);

    // конструктор, инициализирующий строку данными из 
    // символьного массива заданной длины
    CMyString(const char * pString, size_t length);

    // конструктор копирования
    CMyString(CMyString const& other);

    // перемещающий конструктор
    //  реализуется совместно с перемещающим оператором присваивания 
    CMyString(CMyString && other) noexcept;

    // конструктор, инициализирующий строку данными из 
    // строки стандартной библиотеки C++
    CMyString(std::string const& stlString);

    // деструктор класса - освобождает память, занимаемую символами строки
    ~CMyString();

    // возвращает длину строки (без учета завершающего нулевого символа)
    size_t GetLength()const;

    // возвращает указатель на массив символов строки.
    // В конце массива обязательно должен быть завершающий нулевой символ
    // даже если строка пустая 
    const char* GetStringData()const;

    // возвращает подстроку с заданной позиции длиной не больше length символов
    CMyString SubString(size_t start, size_t length = SIZE_MAX)const;

    // очистка строки (строка становится снова нулевой длины)
    void Clear();

    // Возвращает вместимость строки
    size_t GetCapacity();
};
Подсказка: чтобы после перемещения строка-донор оставалась в валидном состоянии (имела завершающий нулевой символ), можно использовать следующий трюк:

Заведите статический массив из 1 символа с нулевым кодом.
Строке после перемещения задайте нулевой размер и нулевую вместимость, а указатель на данные переставьте на первый элемент статического массива. Таким образом все строки после перемещения будут пустыми и будут использовать один и тот же массив из одного элемента для хранения символов.
Не вызывайте оператор delete[] для указателей, ссылающихся на этот статический массив.
Для хранения символов строки не допускается использовать классы вроде std::string и std::vector. Управление данными в динамической памяти должно быть реализовано целиком силами Вашего класса.